/*--------------------1--------------------*/
//Напишите функцию, которая заполняет новый массив предоставленным значением.
//(3, 'a') => ['a', 'a', 'a']
const fill = (arraySize, value) => {
  arr = Array(arraySize).fill(value)
  return arr
  //Метод fill() заполняет все элементы массива от начального до конечного индексов одним значением.
  //Метод fill принимает до трёх аргументов — value, start и end. 
  //Аргументы start и end являются необязательными со значениями по умолчанию, равными 0 и length объекта this соответственно.
 }

/*--------------------2--------------------*/
//Напишите функцию, которая разворачивает массив в обратном порядке.
//[1, 2, 3] => [3, 2, 1]
const reverse = (array) => {
  return array.reverse()
  //reverse - разворачивает массив в обратном порядке.
 }

/*--------------------3--------------------*/
 //Описание задачи: Напишите функцию, которая очищает массив от нежелательных значений, 
 //таких как false, undefined, пустые строки, ноль, null.
 // * Ожидаемый результат: [0, 1, false, 2, undefined, '', 3, null] => [1, 2, 3]
 const compact = (array) => {
  return array.filter((el) => el)
 }
  const arr = [0, 1, false, 2, undefined, '', 3, null]
 console.log(compact(arr))
/*
  Метод filter() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, 
  и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true. 
  Функция callback вызывается только для индексов массива с уже определёнными значениями;
  она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались. 
  Элементы массива, не прошедшие проверку функцией callback, просто пропускаются и не включаются в новый массив.
  --Функция callback вызывается с тремя аргументам:
  1)значение элемента;
  2)индекс элемента;
  3)массив, по которому осуществляется проход.
*/

 /*--------------------4--------------------*/
 /**
  * Описание задачи: Напишите функцию, которая возвращает объект, составленный из значений вложенных массивов. 
  * Первое значение - ключ, второе - зачение.
  * Ожидаемый результат: [['a', 1], ['b', 2]] => { a: 1, b: 2 }
*/
const fromPairs = (array) => array.reduce((acc, value) =>{
  if (Array.isArray(value)) {
    acc[value[0]] = value[1];
  }
  return acc;
}, {})
 const data = [['a', 1],['r', 2],['b', 9],['g', 2],['z', 7],];
 console.log(fromPairs(data))

 //Метод Array.isArray() возвращает true, если объект является массивом и false, если он массивом не является.
 /*
  Метод reduce() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот,
  принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback), значение текущего элемента,
  текущий индекс и массив, по которому происходит итерация.

  При первом вызове функции, параметры accumulator и currentValue могут принимать одно из двух значений.
  Если при вызове reduce() передан аргумент initialValue, то значение accumulator будет равным значению initialValue,
  а значение currentValue будет равным первому значению в массиве. Если аргумент initialValue не задан,
  то значение accumulator будет равным первому значению в массиве, а значение currentValue будет равным второму значению в массиве.
 */

 /*--------------------5--------------------*/
  //Напишите функцию, возвращает новый массив без предоставленных значений. Используйте примитивные типы.
  //Ожидаемый результат: [1, 2, 3, 4, 5, 1, 2, 3, 4,] без 1, 2, 3, 4 => [5]

  const without = (array, ...args) => {
    let arr = [...array];
      for (let i = 0; i < args.length; i++) {
        arr = arr.filter((el) => el !== args[i]);
      }
    return arr;
  }
const mass = [1, 2, 3, 4, 5, 1, 2, 3, 4,];
console.log(without(mass, 1, 2, 3, 4));

  /*--------------------6--------------------*/
//Напишите функцию, которая убирает повторяющиеся значения.
//Ожидаемый результат: [1, 2, 3, 4, 5, 1, 2, 3, 4,] => [1, 2, 3, 4, 5,]

const repeat = (array) => {
  const uniqSet = new Set(array);
  return [...uniqSet];
}
const mass2 = [1, 2, 3, 4, 5, 1, 2, 3, 4]
console.log(repeat(mass2));

// Объекты Set представляют коллекции значений, по которым вы можете выполнить обход в порядке вставки элементов.
// Значение элемента в Set может присутствовать только в одном экземпляре, что обеспечивает его уникальность в коллекции Set.

  /*--------------------7--------------------*/

  const isEqual = (firstArray, secondArray) => {
    if(JSON.stringify(firstArray) === JSON.stringify(secondArray)) return true
    else return false
  }
  const arr1 = [1, 2, 3, 4];
  const arr2 = [1, 2, 3, 4];
  const arr3 = [1, 2, 3, 5];
  const arr4 = [1, 2, 3, 4, 5];
  console.log(isEqual(arr1, arr2)); // true
  console.log(isEqual(arr1, arr3)); // false
  console.log(isEqual(arr1, arr4)); // false
  //Метод JSON.stringify() преобразует значение JavaScript в строку JSON, 
  //возможно с заменой значений, если указана функция замены, или с включением только определённых свойств, если указан массив замены.

  /*--------------------8--------------------*/
  /**
  * Описание задачи: Напишите функцию, которая преобразует глубокий массив в одномерный.
  * Ожидаемый результат: [1, 2, [3, 4, [5]]] => [1, 2, 3, 4, 5]
*/
const flatten = (array) => {
  return array.flat(Infinity)
 }
 const data2 = [1, 2, [3, 4, [5]]];
 console.log(flatten(data2)); // [1, 2, 3, 4, 5]

 //Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты".
 //arr1.flat(); arr3.flat(2); arr4.flat(Infinity);

  /*--------------------9--------------------*/

  /**
  * Описание задачи: Напишите функцию, которая разделяет массив на части заданного размера.
  * Ожидаемый результат: ([1, 2, 3, 4, 5], 2) => [[1, 2], [3, 4], [5]]
*/
const chunk = (array, size) => {
  let subarray = []; //массив в который будет выведен результат.
  for (let i = 0; i <Math.ceil(array.length/size); i++){
    subarray[i] = array.slice((i*size), (i*size) + size);
  }
  return subarray
 }
 
 const data3 = [1, 2, 3, 4, 5, 6, 7];
 console.log(chunk(data3, 2)) // [[1, 2], [3, 4], [5, 6], [7]]
 console.log(chunk(data3, 3)) // [[1, 2, 3], [4, 5, 6], [7]]
// Метод Math.ceil() - округление вверх. Округляет аргумент до ближайшего большего целого.
// Метод slice() возвращает новый массив, содержащий копию части исходного массива.
// arr.slice([begin[, end]]) - begin индекс (счёт начинается с нуля), по которому начинать извлечение.
// Eсли индекс отрицательный, begin указывает смещение от конца последовательности. Вызов slice(-2) извлечёт два последних элемента последовательности.
// Если begin не определён, slice() начинает работать с индекса 0. Если begin больше длины последовательности вернётся пустой массив.
// End - Индекс (счёт начинается с нуля), по которому заканчивать извлечение. Метод slice() извлекает элементы с индексом меньше end.
// Вызов slice(1, 4) извлечёт элементы со второго по четвёртый (элементы по индексам 1, 2 и 3).




